#!/bin/bash

# VPS Security Audit Script
# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# Symbols
CHECK="✓"
CROSS="✗"
WARN="⚠"
INFO="ℹ"

# Counters
PASS=0
FAIL=0
WARN_COUNT=0

# Animation function
spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\'
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
}

# Progress bar
progress_bar() {
    local duration=$1
    local width=40
    for ((i=0; i<=width; i++)); do
        local percent=$((i * 100 / width))
        local filled=$((i))
        local empty=$((width - i))
        printf "\r${CYAN}["
        printf "%${filled}s" | tr ' ' '='
        printf "%${empty}s" | tr ' ' ' '
        printf "] ${percent}%%${NC}"
        sleep $(echo "$duration / $width" | bc -l)
    done
    echo
}

# Print functions
print_header() {
    echo -e "${BOLD}${CYAN}"
    echo '  ______ _____                              _ _ _             '
    echo ' |  ____/ ____|  /\          /\            | (_) |            '
    echo ' | |__ | (___   /  \ ______ /  \  _   _  __| |_| |_ ___  _ __ '
    echo ' |  __| \___ \ / /\ \______/ /\ \| | | |/ _` | | __/ _ \| __|'
    echo ' | |    ____) / ____ \    / ____ \ |_| | (_| | | || (_) | |   '
    echo ' |_|   |_____/_/    \_\  /_/    \_\__,_|\__,_|_|\__\___/|_|   '
    echo -e "${NC}"
    echo -e "${WHITE}          Full Stack VPS Security Auditor v1.0${NC}"
    echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
}

print_section() {
    echo
    echo -e "${BOLD}${BLUE}╔════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}${BLUE}║ $1${NC}"
    echo -e "${BOLD}${BLUE}╚════════════════════════════════════════════════════════╝${NC}"
    echo
}

print_pass() {
    echo -e "${GREEN}  ${CHECK} ${1}${NC}"
    ((PASS++))
}

print_fail() {
    echo -e "${RED}  ${CROSS} ${1}${NC}"
    echo -e "${RED}     → ${2}${NC}"
    ((FAIL++))
}

print_warn() {
    echo -e "${YELLOW}  ${WARN} ${1}${NC}"
    echo -e "${YELLOW}     → ${2}${NC}"
    ((WARN_COUNT++))
}

print_info() {
    echo -e "${CYAN}  ${INFO} ${1}${NC}"
}

# Check if running as root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        echo -e "${RED}This script must be run as root (use sudo)${NC}"
        exit 1
    fi
}

# System Information
get_system_info() {
    print_section "System Information"
    
    print_info "Hostname: $(hostname)"
    print_info "OS: $(cat /etc/os-release | grep PRETTY_NAME | cut -d'"' -f2)"
    print_info "Kernel: $(uname -r)"
    print_info "Uptime: $(uptime -p)"
    print_info "IP Address: $(hostname -I | awk '{print $1}')"
}

# SSH Security Audit
audit_ssh() {
    print_section "SSH Security Configuration"
    
    SSH_CONFIG="/etc/ssh/sshd_config"
    
    if [ ! -f "$SSH_CONFIG" ]; then
        print_fail "SSH config not found" "Is SSH installed?"
        return
    fi
    
    # Check SSH Port
    SSH_PORT=$(grep "^Port " $SSH_CONFIG | awk '{print $2}')
    if [ -z "$SSH_PORT" ]; then
        SSH_PORT=22
    fi
    
    if [ "$SSH_PORT" = "22" ]; then
        print_warn "SSH running on default port 22" "Consider changing to non-standard port"
    else
        print_pass "SSH running on non-standard port: $SSH_PORT"
    fi
    
    # Root Login
    ROOT_LOGIN=$(grep "^PermitRootLogin" $SSH_CONFIG | awk '{print $2}')
    if [ "$ROOT_LOGIN" = "no" ]; then
        print_pass "Root login is disabled"
    else
        print_fail "Root login is ENABLED" "Set 'PermitRootLogin no' in $SSH_CONFIG"
    fi
    
    # Password Authentication
    PASS_AUTH=$(grep "^PasswordAuthentication" $SSH_CONFIG | awk '{print $2}')
    if [ "$PASS_AUTH" = "no" ]; then
        print_pass "Password authentication is disabled (key-only)"
    else
        print_fail "Password authentication is ENABLED" "Set 'PasswordAuthentication no' and use SSH keys"
    fi
    
    # Protocol version
    PROTOCOL=$(grep "^Protocol" $SSH_CONFIG | awk '{print $2}')
    if [ -z "$PROTOCOL" ] || [ "$PROTOCOL" = "2" ]; then
        print_pass "Using SSH Protocol 2"
    else
        print_fail "Not using SSH Protocol 2" "Set 'Protocol 2' in $SSH_CONFIG"
    fi
    
    # Empty passwords
    EMPTY_PASS=$(grep "^PermitEmptyPasswords" $SSH_CONFIG | awk '{print $2}')
    if [ "$EMPTY_PASS" = "no" ] || [ -z "$EMPTY_PASS" ]; then
        print_pass "Empty passwords not permitted"
    else
        print_fail "Empty passwords are PERMITTED" "Set 'PermitEmptyPasswords no'"
    fi
    
    # X11 Forwarding
    X11=$(grep "^X11Forwarding" $SSH_CONFIG | awk '{print $2}')
    if [ "$X11" = "no" ]; then
        print_pass "X11 Forwarding disabled"
    else
        print_warn "X11 Forwarding enabled" "Disable if not needed: 'X11Forwarding no'"
    fi
    
    # MaxAuthTries
    MAX_AUTH=$(grep "^MaxAuthTries" $SSH_CONFIG | awk '{print $2}')
    if [ ! -z "$MAX_AUTH" ] && [ "$MAX_AUTH" -le 3 ]; then
        print_pass "MaxAuthTries is set to $MAX_AUTH"
    else
        print_warn "MaxAuthTries not optimally configured" "Set 'MaxAuthTries 3'"
    fi
}

# Firewall Check
audit_firewall() {
    print_section "Firewall Configuration"
    
    # Check UFW
    if command -v ufw &> /dev/null; then
        UFW_STATUS=$(ufw status | grep "Status:" | awk '{print $2}')
        if [ "$UFW_STATUS" = "active" ]; then
            print_pass "UFW firewall is active"
            echo
            print_info "UFW Rules:"
            ufw status numbered | grep -v "Status:" | sed 's/^/     /'
        else
            print_fail "UFW is installed but INACTIVE" "Enable with: ufw enable"
        fi
    # Check iptables
    elif command -v iptables &> /dev/null; then
        RULES_COUNT=$(iptables -L | grep -c "Chain")
        if [ "$RULES_COUNT" -gt 3 ]; then
            print_pass "iptables firewall has rules configured"
            print_info "Active chains: $RULES_COUNT"
        else
            print_warn "iptables installed but minimal rules" "Configure firewall rules"
        fi
    else
        print_fail "No firewall detected" "Install and configure UFW or iptables"
    fi
}

# Open Ports Scan
audit_ports() {
    print_section "Open Ports Analysis"
    
    print_info "Scanning listening ports..."
    echo
    
    if command -v ss &> /dev/null; then
        LISTENING=$(ss -tuln | grep LISTEN)
    else
        LISTENING=$(netstat -tuln | grep LISTEN)
    fi
    
    echo -e "${CYAN}  Port    Service         Status${NC}"
    echo -e "${CYAN}  ────────────────────────────────${NC}"
    
    # Common ports to check
    declare -A COMMON_PORTS=(
        [22]="SSH"
        [80]="HTTP"
        [443]="HTTPS"
        [3306]="MySQL"
        [5432]="PostgreSQL"
        [6379]="Redis"
        [27017]="MongoDB"
        [8080]="Alt-HTTP"
        [9000]="PHP-FPM"
        [25]="SMTP"
    )
    
    for port in "${!COMMON_PORTS[@]}"; do
        if echo "$LISTENING" | grep -q ":$port "; then
            SERVICE="${COMMON_PORTS[$port]}"
            
            # Check if bound to localhost only
            if echo "$LISTENING" | grep ":$port " | grep -q "127.0.0.1"; then
                echo -e "${GREEN}  $port     $SERVICE         Localhost only ✓${NC}"
            else
                if [ "$port" = "22" ] || [ "$port" = "80" ] || [ "$port" = "443" ]; then
                    echo -e "${GREEN}  $port     $SERVICE         Public (Normal) ✓${NC}"
                else
                    echo -e "${YELLOW}  $port     $SERVICE         Public (Review!) ${WARN}${NC}"
                    ((WARN_COUNT++))
                fi
            fi
        fi
    done
    
    # Check for unexpected ports
    echo
    print_info "All listening ports:"
    if command -v ss &> /dev/null; then
        ss -tuln | grep LISTEN | awk '{print "     " $5}' | sed 's/.*:/Port: /' | sort -u
    else
        netstat -tuln | grep LISTEN | awk '{print "     " $4}' | sed 's/.*:/Port: /' | sort -u
    fi
}

# User Account Security
audit_users() {
    print_section "User Account Security"
    
    # Check for users with UID 0 (root privileges)
    ROOT_USERS=$(awk -F: '$3 == 0 {print $1}' /etc/passwd)
    ROOT_COUNT=$(echo "$ROOT_USERS" | wc -l)
    
    if [ "$ROOT_COUNT" -eq 1 ]; then
        print_pass "Only one root user (UID 0)"
    else
        print_fail "Multiple users with UID 0 found" "Users: $ROOT_USERS"
    fi
    
    # Check for users with empty passwords
    EMPTY_PASS_USERS=$(awk -F: '$2 == "" {print $1}' /etc/shadow 2>/dev/null)
    if [ -z "$EMPTY_PASS_USERS" ]; then
        print_pass "No users with empty passwords"
    else
        print_fail "Users with empty passwords found" "Users: $EMPTY_PASS_USERS"
    fi
    
    # Check for users with login shells
    print_info "Users with login shells:"
    grep -v "nologin\|false" /etc/passwd | grep -v "^#" | awk -F: '{print "     " $1 " (" $7 ")"}'
    
    # Check sudo group
    echo
    if command -v getent &> /dev/null; then
        SUDO_USERS=$(getent group sudo | cut -d: -f4)
        if [ ! -z "$SUDO_USERS" ]; then
            print_info "Users with sudo access: $SUDO_USERS"
        fi
    fi
}

# Docker Security
audit_docker() {
    print_section "Docker Security"
    
    if ! command -v docker &> /dev/null; then
        print_info "Docker is not installed"
        return
    fi
    
    print_pass "Docker is installed"
    
    # Docker version
    DOCKER_VERSION=$(docker --version | awk '{print $3}' | tr -d ',')
    print_info "Version: $DOCKER_VERSION"
    
    # Running containers
    RUNNING=$(docker ps -q | wc -l)
    print_info "Running containers: $RUNNING"
    
    if [ "$RUNNING" -gt 0 ]; then
        echo
        print_info "Container details:"
        docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Ports}}" | sed 's/^/     /'
        
        # Check for containers running as root
        echo
        print_info "Checking container users..."
        for container in $(docker ps -q); do
            CONTAINER_NAME=$(docker inspect --format='{{.Name}}' $container | sed 's/\///')
            USER=$(docker inspect --format='{{.Config.User}}' $container)
            if [ -z "$USER" ] || [ "$USER" = "root" ]; then
                print_warn "Container '$CONTAINER_NAME' running as root" "Consider running as non-root user"
            else
                print_pass "Container '$CONTAINER_NAME' running as user: $USER"
            fi
        done
        
        # Check for exposed ports
        echo
        print_info "Checking exposed ports..."
        for container in $(docker ps -q); do
            CONTAINER_NAME=$(docker inspect --format='{{.Name}}' $container | sed 's/\///')
            PORTS=$(docker port $container 2>/dev/null)
            if [ ! -z "$PORTS" ]; then
                echo -e "${CYAN}     $CONTAINER_NAME:${NC}"
                echo "$PORTS" | sed 's/^/       /'
            fi
        done
    fi
    
    # Check Docker daemon
    echo
    if [ -f /etc/docker/daemon.json ]; then
        print_pass "Docker daemon.json exists"
        if grep -q "userns-remap" /etc/docker/daemon.json 2>/dev/null; then
            print_pass "User namespace remapping enabled"
        else
            print_warn "User namespace remapping not enabled" "Consider enabling for better isolation"
        fi
    else
        print_warn "No daemon.json configuration" "Consider creating /etc/docker/daemon.json"
    fi
}

# Database Security
audit_databases() {
    print_section "Database Security"
    
    # PostgreSQL
    if command -v psql &> /dev/null || [ -d /var/lib/postgresql ]; then
        echo -e "${BOLD}PostgreSQL:${NC}"
        
        if systemctl is-active --quiet postgresql; then
            print_pass "PostgreSQL service is running"
            
            # Check if listening on public interface
            if ss -tuln 2>/dev/null | grep ":5432" | grep -q "0.0.0.0\|::"; then
                print_warn "PostgreSQL listening on public interface" "Restrict to localhost if not needed"
            else
                print_pass "PostgreSQL bound to localhost"
            fi
        else
            print_info "PostgreSQL installed but not running"
        fi
        echo
    fi
    
    # MySQL/MariaDB
    if command -v mysql &> /dev/null || [ -d /var/lib/mysql ]; then
        echo -e "${BOLD}MySQL/MariaDB:${NC}"
        
        if systemctl is-active --quiet mysql || systemctl is-active --quiet mariadb; then
            print_pass "MySQL/MariaDB service is running"
            
            if ss -tuln 2>/dev/null | grep ":3306" | grep -q "0.0.0.0\|::"; then
                print_warn "MySQL listening on public interface" "Restrict to localhost if not needed"
            else
                print_pass "MySQL bound to localhost"
            fi
        else
            print_info "MySQL/MariaDB installed but not running"
        fi
        echo
    fi
    
    # Redis
    if command -v redis-cli &> /dev/null; then
        echo -e "${BOLD}Redis:${NC}"
        
        if systemctl is-active --quiet redis || systemctl is-active --quiet redis-server; then
            print_pass "Redis service is running"
            
            if ss -tuln 2>/dev/null | grep ":6379" | grep -q "0.0.0.0\|::"; then
                print_warn "Redis listening on public interface" "Should be localhost-only!"
            else
                print_pass "Redis bound to localhost"
            fi
            
            # Check if password is set
            if redis-cli ping 2>/dev/null | grep -q "PONG"; then
                print_fail "Redis has NO PASSWORD set" "Set requirepass in redis.conf"
            else
                print_pass "Redis password is configured"
            fi
        else
            print_info "Redis installed but not running"
        fi
        echo
    fi
}

# System Updates
audit_updates() {
    print_section "System Updates & Patches"
    
    if command -v apt &> /dev/null; then
        print_info "Checking for updates (this may take a moment)..."
        apt update -qq 2>/dev/null
        UPDATES=$(apt list --upgradable 2>/dev/null | grep -c upgradable)
        
        if [ "$UPDATES" -le 1 ]; then
            print_pass "System is up to date"
        else
            print_warn "$((UPDATES-1)) updates available" "Run: apt upgrade"
        fi
        
        # Check if unattended-upgrades is installed
        if dpkg -l | grep -q unattended-upgrades; then
            print_pass "Unattended-upgrades is installed"
        else
            print_warn "Unattended-upgrades not installed" "Install for automatic security updates"
        fi
    elif command -v yum &> /dev/null; then
        UPDATES=$(yum check-update 2>/dev/null | grep -c "updates")
        if [ "$UPDATES" -eq 0 ]; then
            print_pass "System is up to date"
        else
            print_warn "$UPDATES updates available" "Run: yum update"
        fi
    fi
}

# Security Tools
audit_security_tools() {
    print_section "Security Tools & Services"
    
    # Fail2ban
    if command -v fail2ban-client &> /dev/null; then
        if systemctl is-active --quiet fail2ban; then
            print_pass "Fail2ban is installed and running"
            BANNED=$(fail2ban-client status sshd 2>/dev/null | grep "Currently banned" | awk '{print $4}')
            print_info "Currently banned IPs: $BANNED"
        else
            print_warn "Fail2ban installed but not running" "Start with: systemctl start fail2ban"
        fi
    else
        print_warn "Fail2ban not installed" "Install to protect against brute-force attacks"
    fi
    
    # AppArmor/SELinux
    if command -v aa-status &> /dev/null; then
        if systemctl is-active --quiet apparmor; then
            print_pass "AppArmor is active"
        else
            print_warn "AppArmor installed but not active" "Enable for additional security"
        fi
    elif command -v getenforce &> /dev/null; then
        SELINUX=$(getenforce)
        if [ "$SELINUX" = "Enforcing" ]; then
            print_pass "SELinux is enforcing"
        else
            print_warn "SELinux is not enforcing: $SELINUX" "Consider enabling SELinux"
        fi
    else
        print_info "No MAC system (AppArmor/SELinux) detected"
    fi
    
    # Check for rootkit scanners
    if command -v rkhunter &> /dev/null; then
        print_pass "RKHunter (rootkit scanner) is installed"
    else
        print_info "RKHunter not installed (optional)"
    fi
}

# File Permissions
audit_permissions() {
    print_section "Critical File Permissions"
    
    # Check /etc/passwd
    PASSWD_PERM=$(stat -c %a /etc/passwd)
    if [ "$PASSWD_PERM" = "644" ]; then
        print_pass "/etc/passwd permissions correct (644)"
    else
        print_warn "/etc/passwd has permissions: $PASSWD_PERM" "Should be 644"
    fi
    
    # Check /etc/shadow
    SHADOW_PERM=$(stat -c %a /etc/shadow 2>/dev/null)
    if [ "$SHADOW_PERM" = "640" ] || [ "$SHADOW_PERM" = "600" ]; then
        print_pass "/etc/shadow permissions correct ($SHADOW_PERM)"
    else
        print_warn "/etc/shadow has permissions: $SHADOW_PERM" "Should be 640 or 600"
    fi
    
    # Check for world-writable files
    print_info "Checking for world-writable files in /etc..."
    WRITABLE=$(find /etc -type f -perm -002 2>/dev/null | wc -l)
    if [ "$WRITABLE" -eq 0 ]; then
        print_pass "No world-writable files in /etc"
    else
        print_warn "$WRITABLE world-writable files found in /etc" "Review and fix permissions"
    fi
}

# Generate Summary
generate_summary() {
    echo
    echo -e "${BOLD}${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BOLD}${WHITE}                    AUDIT SUMMARY${NC}"
    echo -e "${BOLD}${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
    
    TOTAL=$((PASS + FAIL + WARN_COUNT))
    
    echo -e "${GREEN}  ${CHECK} Passed:   $PASS${NC}"
    echo -e "${RED}  ${CROSS} Failed:   $FAIL${NC}"
    echo -e "${YELLOW}  ${WARN} Warnings: $WARN_COUNT${NC}"
    echo -e "${CYAN}  ═ Total:    $TOTAL${NC}"
    echo
    
    # Calculate security score
    SCORE=$((PASS * 100 / TOTAL))
    
    echo -e "${BOLD}Security Score: "
    if [ "$SCORE" -ge 80 ]; then
        echo -e "${GREEN}${SCORE}% - GOOD${NC}"
    elif [ "$SCORE" -ge 60 ]; then
        echo -e "${YELLOW}${SCORE}% - MODERATE${NC}"
    else
        echo -e "${RED}${SCORE}% - NEEDS IMPROVEMENT${NC}"
    fi
    echo
    
    # Priority recommendations
    if [ "$FAIL" -gt 0 ]; then
        echo -e "${BOLD}${RED}Priority Actions Required:${NC}"
        echo -e "${RED}  • Address all failed checks immediately${NC}"
        echo -e "${RED}  • Review SSH configuration${NC}"
        echo -e "${RED}  • Ensure firewall is active${NC}"
        echo
    fi
    
    if [ "$WARN_COUNT" -gt 0 ]; then
        echo -e "${BOLD}${YELLOW}Recommended Improvements:${NC}"
        echo -e "${YELLOW}  • Review warnings above${NC}"
        echo -e "${YELLOW}  • Consider installing Fail2ban${NC}"
        echo -e "${YELLOW}  • Enable automatic security updates${NC}"
        echo
    fi
    
    echo -e "${CYAN}Audit completed at: $(date '+%Y-%m-%d %H:%M:%S')${NC}"
    echo -e "${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
}

# Main execution
main() {
    clear
    print_header
    
    check_root
    
    echo -e "${CYAN}Initializing security audit...${NC}"
    progress_bar 1
    
    get_system_info
    audit_ssh
    audit_firewall
    audit_ports
    audit_users
    audit_docker
    audit_databases
    audit_updates
    audit_security_tools
    audit_permissions
    
    generate_summary
    
    echo -e "${BOLD}${CYAN}Tip: Run this audit regularly to maintain security!${NC}"
    echo -e "${CYAN}Save output: sudo ./audit.sh | tee security-audit.log${NC}"
    echo
}

# Run main function
main
